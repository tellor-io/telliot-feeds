# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/nft/v1beta1/event.proto, cosmos/nft/v1beta1/genesis.proto, cosmos/nft/v1beta1/nft.proto, cosmos/nft/v1beta1/query.proto, cosmos/nft/v1beta1/tx.proto
# plugin: python-betterproto
# This file has been @generated
from dataclasses import dataclass
from typing import Dict
from typing import List
from typing import Optional
from typing import TYPE_CHECKING

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...base.query import v1beta1 as __base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class MsgSend(betterproto.Message):
    """
    MsgSend represents a message to send a nft from one account to another account.
    """

    class_id: str = betterproto.string_field(1)
    """
    class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721
    """

    id: str = betterproto.string_field(2)
    """id defines the unique identification of nft"""

    sender: str = betterproto.string_field(3)
    """sender is the address of the owner of nft"""

    receiver: str = betterproto.string_field(4)
    """receiver is the receiver address of nft"""


@dataclass(eq=False, repr=False)
class MsgSendResponse(betterproto.Message):
    """MsgSendResponse defines the Msg/Send response type."""

    pass


@dataclass(eq=False, repr=False)
class Class(betterproto.Message):
    """Class defines the class of the nft type."""

    id: str = betterproto.string_field(1)
    """
    id defines the unique identifier of the NFT classification, similar to the contract address of ERC721
    """

    name: str = betterproto.string_field(2)
    """
    name defines the human-readable name of the NFT classification. Optional
    """

    symbol: str = betterproto.string_field(3)
    """symbol is an abbreviated name for nft classification. Optional"""

    description: str = betterproto.string_field(4)
    """description is a brief description of nft classification. Optional"""

    uri: str = betterproto.string_field(5)
    """
    uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional
    """

    uri_hash: str = betterproto.string_field(6)
    """uri_hash is a hash of the document pointed by uri. Optional"""

    data: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(7)
    """data is the app specific metadata of the NFT class. Optional"""


@dataclass(eq=False, repr=False)
class Nft(betterproto.Message):
    """NFT defines the NFT."""

    class_id: str = betterproto.string_field(1)
    """
    class_id associated with the NFT, similar to the contract address of ERC721
    """

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the NFT"""

    uri: str = betterproto.string_field(3)
    """uri for the NFT metadata stored off chain"""

    uri_hash: str = betterproto.string_field(4)
    """uri_hash is a hash of the document pointed by uri"""

    data: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(10)
    """data is an app specific data of the NFT. Optional"""


@dataclass(eq=False, repr=False)
class QueryBalanceRequest(betterproto.Message):
    """
    QueryBalanceRequest is the request type for the Query/Balance RPC method
    """

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    owner: str = betterproto.string_field(2)
    """owner is the owner address of the nft"""


@dataclass(eq=False, repr=False)
class QueryBalanceResponse(betterproto.Message):
    """
    QueryBalanceResponse is the response type for the Query/Balance RPC method
    """

    amount: int = betterproto.uint64_field(1)
    """amount is the number of all NFTs of a given class owned by the owner"""


@dataclass(eq=False, repr=False)
class QueryOwnerRequest(betterproto.Message):
    """QueryOwnerRequest is the request type for the Query/Owner RPC method"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the NFT"""


@dataclass(eq=False, repr=False)
class QueryOwnerResponse(betterproto.Message):
    """
    QueryOwnerResponse is the response type for the Query/Owner RPC method
    """

    owner: str = betterproto.string_field(1)
    """owner is the owner address of the nft"""


@dataclass(eq=False, repr=False)
class QuerySupplyRequest(betterproto.Message):
    """
    QuerySupplyRequest is the request type for the Query/Supply RPC method
    """

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""


@dataclass(eq=False, repr=False)
class QuerySupplyResponse(betterproto.Message):
    """
    QuerySupplyResponse is the response type for the Query/Supply RPC method
    """

    amount: int = betterproto.uint64_field(1)
    """amount is the number of all NFTs from the given class"""


@dataclass(eq=False, repr=False)
class QueryNfTsRequest(betterproto.Message):
    """QueryNFTstRequest is the request type for the Query/NFTs RPC method"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    owner: str = betterproto.string_field(2)
    """owner is the owner address of the nft"""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(3)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryNfTsResponse(betterproto.Message):
    """
    QueryNFTsResponse is the response type for the Query/NFTs RPC methods
    """

    nfts: List["Nft"] = betterproto.message_field(1)
    """NFT defines the NFT"""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryNftRequest(betterproto.Message):
    """QueryNFTRequest is the request type for the Query/NFT RPC method"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the NFT"""


@dataclass(eq=False, repr=False)
class QueryNftResponse(betterproto.Message):
    """QueryNFTResponse is the response type for the Query/NFT RPC method"""

    nft: "Nft" = betterproto.message_field(1)
    """owner is the owner address of the nft"""


@dataclass(eq=False, repr=False)
class QueryClassRequest(betterproto.Message):
    """QueryClassRequest is the request type for the Query/Class RPC method"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""


@dataclass(eq=False, repr=False)
class QueryClassResponse(betterproto.Message):
    """
    QueryClassResponse is the response type for the Query/Class RPC method
    """

    class_: "Class" = betterproto.message_field(1)
    """class defines the class of the nft type."""


@dataclass(eq=False, repr=False)
class QueryClassesRequest(betterproto.Message):
    """
    QueryClassesRequest is the request type for the Query/Classes RPC method
    """

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryClassesResponse(betterproto.Message):
    """
    QueryClassesResponse is the response type for the Query/Classes RPC method
    """

    classes: List["Class"] = betterproto.message_field(1)
    """class defines the class of the nft type."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class EventSend(betterproto.Message):
    """EventSend is emitted on Msg/Send"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the nft"""

    sender: str = betterproto.string_field(3)
    """sender is the address of the owner of nft"""

    receiver: str = betterproto.string_field(4)
    """receiver is the receiver address of nft"""


@dataclass(eq=False, repr=False)
class EventMint(betterproto.Message):
    """EventMint is emitted on Mint"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the nft"""

    owner: str = betterproto.string_field(3)
    """owner is the owner address of the nft"""


@dataclass(eq=False, repr=False)
class EventBurn(betterproto.Message):
    """EventBurn is emitted on Burn"""

    class_id: str = betterproto.string_field(1)
    """class_id associated with the nft"""

    id: str = betterproto.string_field(2)
    """id is a unique identifier of the nft"""

    owner: str = betterproto.string_field(3)
    """owner is the owner address of the nft"""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the nft module's genesis state."""

    classes: List["Class"] = betterproto.message_field(1)
    """class defines the class of the nft type."""

    entries: List["Entry"] = betterproto.message_field(2)
    """entry defines all nft owned by a person."""


@dataclass(eq=False, repr=False)
class Entry(betterproto.Message):
    """Entry Defines all nft owned by a person"""

    owner: str = betterproto.string_field(1)
    """owner is the owner address of the following nft"""

    nfts: List["Nft"] = betterproto.message_field(2)
    """nfts is a group of nfts of the same owner"""


class MsgStub(betterproto.ServiceStub):
    async def send(
        self,
        msg_send: "MsgSend",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgSendResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Msg/Send",
            msg_send,
            MsgSendResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def balance(
        self,
        query_balance_request: "QueryBalanceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryBalanceResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Balance",
            query_balance_request,
            QueryBalanceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def owner(
        self,
        query_owner_request: "QueryOwnerRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryOwnerResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Owner",
            query_owner_request,
            QueryOwnerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def supply(
        self,
        query_supply_request: "QuerySupplyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QuerySupplyResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Supply",
            query_supply_request,
            QuerySupplyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def nf_ts(
        self,
        query_nf_ts_request: "QueryNfTsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryNfTsResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/NFTs",
            query_nf_ts_request,
            QueryNfTsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def nft(
        self,
        query_nft_request: "QueryNftRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryNftResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/NFT",
            query_nft_request,
            QueryNftResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def class_(
        self,
        query_class_request: "QueryClassRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryClassResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Class",
            query_class_request,
            QueryClassResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def classes(
        self,
        query_classes_request: "QueryClassesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryClassesResponse":
        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Classes",
            query_classes_request,
            QueryClassesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def send(self, msg_send: "MsgSend") -> "MsgSendResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send(self, stream: "grpclib.server.Stream[MsgSend, MsgSendResponse]") -> None:
        request = await stream.recv_message()
        response = await self.send(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.nft.v1beta1.Msg/Send": grpclib.const.Handler(
                self.__rpc_send,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSend,
                MsgSendResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def balance(self, query_balance_request: "QueryBalanceRequest") -> "QueryBalanceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def owner(self, query_owner_request: "QueryOwnerRequest") -> "QueryOwnerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def supply(self, query_supply_request: "QuerySupplyRequest") -> "QuerySupplyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def nf_ts(self, query_nf_ts_request: "QueryNfTsRequest") -> "QueryNfTsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def nft(self, query_nft_request: "QueryNftRequest") -> "QueryNftResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def class_(self, query_class_request: "QueryClassRequest") -> "QueryClassResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def classes(self, query_classes_request: "QueryClassesRequest") -> "QueryClassesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_balance(self, stream: "grpclib.server.Stream[QueryBalanceRequest, QueryBalanceResponse]") -> None:
        request = await stream.recv_message()
        response = await self.balance(request)
        await stream.send_message(response)

    async def __rpc_owner(self, stream: "grpclib.server.Stream[QueryOwnerRequest, QueryOwnerResponse]") -> None:
        request = await stream.recv_message()
        response = await self.owner(request)
        await stream.send_message(response)

    async def __rpc_supply(self, stream: "grpclib.server.Stream[QuerySupplyRequest, QuerySupplyResponse]") -> None:
        request = await stream.recv_message()
        response = await self.supply(request)
        await stream.send_message(response)

    async def __rpc_nf_ts(self, stream: "grpclib.server.Stream[QueryNfTsRequest, QueryNfTsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.nf_ts(request)
        await stream.send_message(response)

    async def __rpc_nft(self, stream: "grpclib.server.Stream[QueryNftRequest, QueryNftResponse]") -> None:
        request = await stream.recv_message()
        response = await self.nft(request)
        await stream.send_message(response)

    async def __rpc_class_(self, stream: "grpclib.server.Stream[QueryClassRequest, QueryClassResponse]") -> None:
        request = await stream.recv_message()
        response = await self.class_(request)
        await stream.send_message(response)

    async def __rpc_classes(self, stream: "grpclib.server.Stream[QueryClassesRequest, QueryClassesResponse]") -> None:
        request = await stream.recv_message()
        response = await self.classes(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.nft.v1beta1.Query/Balance": grpclib.const.Handler(
                self.__rpc_balance,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryBalanceRequest,
                QueryBalanceResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Owner": grpclib.const.Handler(
                self.__rpc_owner,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryOwnerRequest,
                QueryOwnerResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Supply": grpclib.const.Handler(
                self.__rpc_supply,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySupplyRequest,
                QuerySupplyResponse,
            ),
            "/cosmos.nft.v1beta1.Query/NFTs": grpclib.const.Handler(
                self.__rpc_nf_ts,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNfTsRequest,
                QueryNfTsResponse,
            ),
            "/cosmos.nft.v1beta1.Query/NFT": grpclib.const.Handler(
                self.__rpc_nft,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNftRequest,
                QueryNftResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Class": grpclib.const.Handler(
                self.__rpc_class_,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryClassRequest,
                QueryClassResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Classes": grpclib.const.Handler(
                self.__rpc_classes,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryClassesRequest,
                QueryClassesResponse,
            ),
        }
