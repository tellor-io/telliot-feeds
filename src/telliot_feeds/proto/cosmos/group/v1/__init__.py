# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/group/v1/events.proto, cosmos/group/v1/genesis.proto, cosmos/group/v1/query.proto, cosmos/group/v1/tx.proto, cosmos/group/v1/types.proto
# plugin: python-betterproto
# This file has been @generated
from dataclasses import dataclass
from datetime import datetime
from datetime import timedelta
from typing import Dict
from typing import List
from typing import Optional
from typing import TYPE_CHECKING

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...base.query import v1beta1 as __base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class VoteOption(betterproto.Enum):
    """VoteOption enumerates the valid vote options for a given proposal."""

    UNSPECIFIED = 0
    """
    VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
     return an error.
    """

    YES = 1
    """VOTE_OPTION_YES defines a yes vote option."""

    ABSTAIN = 2
    """VOTE_OPTION_ABSTAIN defines an abstain vote option."""

    NO = 3
    """VOTE_OPTION_NO defines a no vote option."""

    NO_WITH_VETO = 4
    """VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."""


class ProposalStatus(betterproto.Enum):
    """ProposalStatus defines proposal statuses."""

    UNSPECIFIED = 0
    """An empty value is invalid and not allowed."""

    SUBMITTED = 1
    """Initial status of a proposal when submitted."""

    ACCEPTED = 2
    """
    Final status of a proposal when the final tally is done and the outcome
     passes the group policy's decision policy.
    """

    REJECTED = 3
    """
    Final status of a proposal when the final tally is done and the outcome
     is rejected by the group policy's decision policy.
    """

    ABORTED = 4
    """
    Final status of a proposal when the group policy is modified before the
     final tally.
    """

    WITHDRAWN = 5
    """
    A proposal can be withdrawn before the voting start time by the owner.
     When this happens the final status is Withdrawn.
    """


class ProposalExecutorResult(betterproto.Enum):
    """ProposalExecutorResult defines types of proposal executor results."""

    UNSPECIFIED = 0
    """An empty value is not allowed."""

    NOT_RUN = 1
    """We have not yet run the executor."""

    SUCCESS = 2
    """The executor was successful and proposed action updated state."""

    FAILURE = 3
    """
    The executor returned an error and proposed action didn't update state.
    """


class Exec(betterproto.Enum):
    """
    Exec defines modes of execution of a proposal on creation or on new vote.
    """

    UNSPECIFIED = 0
    """
    An empty value means that there should be a separate
     MsgExec request for the proposal to execute.
    """

    TRY = 1
    """
    Try to execute the proposal immediately.
     If the proposal is not allowed per the DecisionPolicy,
     the proposal will still be open and could
     be executed at a later point.
    """


@dataclass(eq=False, repr=False)
class Member(betterproto.Message):
    """
    Member represents a group member with an account address,
     non-zero weight, metadata and added_at timestamp.
    """

    address: str = betterproto.string_field(1)
    """address is the member's account address."""

    weight: str = betterproto.string_field(2)
    """weight is the member's voting weight that should be greater than 0."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the member."""

    added_at: datetime = betterproto.message_field(4)
    """added_at is a timestamp specifying when a member was added."""


@dataclass(eq=False, repr=False)
class MemberRequest(betterproto.Message):
    """
    MemberRequest represents a group member to be used in Msg server requests.
     Contrary to `Member`, it doesn't have any `added_at` field
     since this field cannot be set as part of requests.
    """

    address: str = betterproto.string_field(1)
    """address is the member's account address."""

    weight: str = betterproto.string_field(2)
    """weight is the member's voting weight that should be greater than 0."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the member."""


@dataclass(eq=False, repr=False)
class ThresholdDecisionPolicy(betterproto.Message):
    """
    ThresholdDecisionPolicy is a decision policy where a proposal passes when it
     satisfies the two following conditions:
     1. The sum of all `YES` voter's weights is greater or equal than the defined
        `threshold`.
     2. The voting and execution periods of the proposal respect the parameters
        given by `windows`.
    """

    threshold: str = betterproto.string_field(1)
    """
    threshold is the minimum weighted sum of `YES` votes that must be met or
     exceeded for a proposal to succeed.
    """

    windows: "DecisionPolicyWindows" = betterproto.message_field(2)
    """windows defines the different windows for voting and execution."""


@dataclass(eq=False, repr=False)
class PercentageDecisionPolicy(betterproto.Message):
    """
    PercentageDecisionPolicy is a decision policy where a proposal passes when
     it satisfies the two following conditions:
     1. The percentage of all `YES` voters' weights out of the total group weight
        is greater or equal than the given `percentage`.
     2. The voting and execution periods of the proposal respect the parameters
        given by `windows`.
    """

    percentage: str = betterproto.string_field(1)
    """
    percentage is the minimum percentage of the weighted sum of `YES` votes must
     meet for a proposal to succeed.
    """

    windows: "DecisionPolicyWindows" = betterproto.message_field(2)
    """windows defines the different windows for voting and execution."""


@dataclass(eq=False, repr=False)
class DecisionPolicyWindows(betterproto.Message):
    """
    DecisionPolicyWindows defines the different windows for voting and execution.
    """

    voting_period: timedelta = betterproto.message_field(1)
    """
    voting_period is the duration from submission of a proposal to the end of voting period
     Within this times votes can be submitted with MsgVote.
    """

    min_execution_period: timedelta = betterproto.message_field(2)
    """
    min_execution_period is the minimum duration after the proposal submission
     where members can start sending MsgExec. This means that the window for
     sending a MsgExec transaction is:
     `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
     where max_execution_period is a app-specific config, defined in the keeper.
     If not set, min_execution_period will default to 0.
    
     Please make sure to set a `min_execution_period` that is smaller than
     `voting_period + max_execution_period`, or else the above execution window
     is empty, meaning that all proposals created with this decision policy
     won't be able to be executed.
    """


@dataclass(eq=False, repr=False)
class GroupInfo(betterproto.Message):
    """
    GroupInfo represents the high-level on-chain information for a group.
    """

    id: int = betterproto.uint64_field(1)
    """id is the unique ID of the group."""

    admin: str = betterproto.string_field(2)
    """admin is the account address of the group's admin."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata to attached to the group."""

    version: int = betterproto.uint64_field(4)
    """
    version is used to track changes to a group's membership structure that
     would break existing proposals. Whenever any members weight is changed,
     or any member is added or removed this version is incremented and will
     cause proposals based on older versions of this group to fail
    """

    total_weight: str = betterproto.string_field(5)
    """total_weight is the sum of the group members' weights."""

    created_at: datetime = betterproto.message_field(6)
    """created_at is a timestamp specifying when a group was created."""


@dataclass(eq=False, repr=False)
class GroupMember(betterproto.Message):
    """
    GroupMember represents the relationship between a group and a member.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""

    member: "Member" = betterproto.message_field(2)
    """member is the member data."""


@dataclass(eq=False, repr=False)
class GroupPolicyInfo(betterproto.Message):
    """
    GroupPolicyInfo represents the high-level on-chain information for a group policy.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of group policy."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    admin: str = betterproto.string_field(3)
    """admin is the account address of the group admin."""

    metadata: str = betterproto.string_field(4)
    """
    metadata is any arbitrary metadata attached to the group policy.
     the recommended format of the metadata is to be found here:
     https://docs.cosmos.network/v0.47/modules/group#decision-policy-1
    """

    version: int = betterproto.uint64_field(5)
    """
    version is used to track changes to a group's GroupPolicyInfo structure that
     would create a different result on a running proposal.
    """

    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(6)
    """decision_policy specifies the group policy's decision policy."""

    created_at: datetime = betterproto.message_field(7)
    """
    created_at is a timestamp specifying when a group policy was created.
    """


@dataclass(eq=False, repr=False)
class Proposal(betterproto.Message):
    """
    Proposal defines a group proposal. Any member of a group can submit a proposal
     for a group policy to decide upon.
     A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
     passes as well as some optional metadata associated with the proposal.
    """

    id: int = betterproto.uint64_field(1)
    """id is the unique id of the proposal."""

    group_policy_address: str = betterproto.string_field(2)
    """group_policy_address is the account address of group policy."""

    metadata: str = betterproto.string_field(3)
    """
    metadata is any arbitrary metadata attached to the proposal.
     the recommended format of the metadata is to be found here:
     https://docs.cosmos.network/v0.47/modules/group#proposal-4
    """

    proposers: List[str] = betterproto.string_field(4)
    """proposers are the account addresses of the proposers."""

    submit_time: datetime = betterproto.message_field(5)
    """submit_time is a timestamp specifying when a proposal was submitted."""

    group_version: int = betterproto.uint64_field(6)
    """
    group_version tracks the version of the group at proposal submission.
     This field is here for informational purposes only.
    """

    group_policy_version: int = betterproto.uint64_field(7)
    """
    group_policy_version tracks the version of the group policy at proposal submission.
     When a decision policy is changed, existing proposals from previous policy
     versions will become invalid with the `ABORTED` status.
     This field is here for informational purposes only.
    """

    status: "ProposalStatus" = betterproto.enum_field(8)
    """
    status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
    """

    final_tally_result: "TallyResult" = betterproto.message_field(9)
    """
    final_tally_result contains the sums of all weighted votes for this
     proposal for each vote option. It is empty at submission, and only
     populated after tallying, at voting period end or at proposal execution,
     whichever happens first.
    """

    voting_period_end: datetime = betterproto.message_field(10)
    """
    voting_period_end is the timestamp before which voting must be done.
     Unless a successful MsgExec is called before (to execute a proposal whose
     tally is successful before the voting period ends), tallying will be done
     at this point, and the `final_tally_result`and `status` fields will be
     accordingly updated.
    """

    executor_result: "ProposalExecutorResult" = betterproto.enum_field(11)
    """
    executor_result is the final result of the proposal execution. Initial value is NotRun.
    """

    messages: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(12)
    """
    messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
    """

    title: str = betterproto.string_field(13)
    """
    title is the title of the proposal
    
     Since: cosmos-sdk 0.47
    """

    summary: str = betterproto.string_field(14)
    """
    summary is a short summary of the proposal
    
     Since: cosmos-sdk 0.47
    """


@dataclass(eq=False, repr=False)
class TallyResult(betterproto.Message):
    """
    TallyResult represents the sum of weighted votes for each vote option.
    """

    yes_count: str = betterproto.string_field(1)
    """yes_count is the weighted sum of yes votes."""

    abstain_count: str = betterproto.string_field(2)
    """abstain_count is the weighted sum of abstainers."""

    no_count: str = betterproto.string_field(3)
    """no_count is the weighted sum of no votes."""

    no_with_veto_count: str = betterproto.string_field(4)
    """no_with_veto_count is the weighted sum of veto."""


@dataclass(eq=False, repr=False)
class Vote(betterproto.Message):
    """Vote represents a vote for a proposal."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""

    voter: str = betterproto.string_field(2)
    """voter is the account address of the voter."""

    option: "VoteOption" = betterproto.enum_field(3)
    """option is the voter's choice on the proposal."""

    metadata: str = betterproto.string_field(4)
    """metadata is any arbitrary metadata attached to the vote."""

    submit_time: datetime = betterproto.message_field(5)
    """submit_time is the timestamp when the vote was submitted."""


@dataclass(eq=False, repr=False)
class MsgCreateGroup(betterproto.Message):
    """MsgCreateGroup is the Msg/CreateGroup request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    members: List["MemberRequest"] = betterproto.message_field(2)
    """members defines the group members."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata to attached to the group."""


@dataclass(eq=False, repr=False)
class MsgCreateGroupResponse(betterproto.Message):
    """MsgCreateGroupResponse is the Msg/CreateGroup response type."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the newly created group."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMembers(betterproto.Message):
    """MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    member_updates: List["MemberRequest"] = betterproto.message_field(3)
    """
    member_updates is the list of members to update,
     set weight to 0 to remove a member.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMembersResponse(betterproto.Message):
    """
    MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupAdmin(betterproto.Message):
    """MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type."""

    admin: str = betterproto.string_field(1)
    """admin is the current account address of the group admin."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    new_admin: str = betterproto.string_field(3)
    """new_admin is the group new admin account address."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupAdminResponse(betterproto.Message):
    """
    MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMetadata(betterproto.Message):
    """MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    metadata: str = betterproto.string_field(3)
    """metadata is the updated group's metadata."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMetadataResponse(betterproto.Message):
    """
    MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgCreateGroupPolicy(betterproto.Message):
    """MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the group policy."""

    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(4)
    """decision_policy specifies the group policy's decision policy."""


@dataclass(eq=False, repr=False)
class MsgCreateGroupPolicyResponse(betterproto.Message):
    """
    MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of the newly created group policy."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyAdmin(betterproto.Message):
    """
    MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_policy_address: str = betterproto.string_field(2)
    """group_policy_address is the account address of the group policy."""

    new_admin: str = betterproto.string_field(3)
    """new_admin is the new group policy admin."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyAdminResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgCreateGroupWithPolicy(betterproto.Message):
    """
    MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group and group policy admin."""

    members: List["MemberRequest"] = betterproto.message_field(2)
    """members defines the group members."""

    group_metadata: str = betterproto.string_field(3)
    """group_metadata is any arbitrary metadata attached to the group."""

    group_policy_metadata: str = betterproto.string_field(4)
    """
    group_policy_metadata is any arbitrary metadata attached to the group policy.
    """

    group_policy_as_admin: bool = betterproto.bool_field(5)
    """
    group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
     and group policy admin.
    """

    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(6)
    """decision_policy specifies the group policy's decision policy."""


@dataclass(eq=False, repr=False)
class MsgCreateGroupWithPolicyResponse(betterproto.Message):
    """
    MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the newly created group with policy."""

    group_policy_address: str = betterproto.string_field(2)
    """
    group_policy_address is the account address of the newly created group policy.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyDecisionPolicy(betterproto.Message):
    """
    MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_policy_address: str = betterproto.string_field(2)
    """group_policy_address is the account address of group policy."""

    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)
    """decision_policy is the updated group policy's decision policy."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyDecisionPolicyResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyMetadata(betterproto.Message):
    """
    MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the account address of the group admin."""

    group_policy_address: str = betterproto.string_field(2)
    """group_policy_address is the account address of group policy."""

    metadata: str = betterproto.string_field(3)
    """metadata is the group policy metadata to be updated."""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyMetadataResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgSubmitProposal(betterproto.Message):
    """MsgSubmitProposal is the Msg/SubmitProposal request type."""

    group_policy_address: str = betterproto.string_field(1)
    """group_policy_address is the account address of group policy."""

    proposers: List[str] = betterproto.string_field(2)
    """
    proposers are the account addresses of the proposers.
     Proposers signatures will be counted as yes votes.
    """

    metadata: str = betterproto.string_field(3)
    """metadata is any arbitrary metadata attached to the proposal."""

    messages: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(4)
    """
    messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
    """

    exec: "Exec" = betterproto.enum_field(5)
    """
    exec defines the mode of execution of the proposal,
     whether it should be executed immediately on creation or not.
     If so, proposers signatures are considered as Yes votes.
    """

    title: str = betterproto.string_field(6)
    """
    title is the title of the proposal.
    
     Since: cosmos-sdk 0.47
    """

    summary: str = betterproto.string_field(7)
    """
    summary is the summary of the proposal.
    
     Since: cosmos-sdk 0.47
    """


@dataclass(eq=False, repr=False)
class MsgSubmitProposalResponse(betterproto.Message):
    """MsgSubmitProposalResponse is the Msg/SubmitProposal response type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""


@dataclass(eq=False, repr=False)
class MsgWithdrawProposal(betterproto.Message):
    """MsgWithdrawProposal is the Msg/WithdrawProposal request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""

    address: str = betterproto.string_field(2)
    """
    address is the admin of the group policy or one of the proposer of the proposal.
    """


@dataclass(eq=False, repr=False)
class MsgWithdrawProposalResponse(betterproto.Message):
    """
    MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgVote(betterproto.Message):
    """MsgVote is the Msg/Vote request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""

    voter: str = betterproto.string_field(2)
    """voter is the voter account address."""

    option: "VoteOption" = betterproto.enum_field(3)
    """option is the voter's choice on the proposal."""

    metadata: str = betterproto.string_field(4)
    """metadata is any arbitrary metadata attached to the vote."""

    exec: "Exec" = betterproto.enum_field(5)
    """
    exec defines whether the proposal should be executed
     immediately after voting or not.
    """


@dataclass(eq=False, repr=False)
class MsgVoteResponse(betterproto.Message):
    """MsgVoteResponse is the Msg/Vote response type."""

    pass


@dataclass(eq=False, repr=False)
class MsgExec(betterproto.Message):
    """MsgExec is the Msg/Exec request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal is the unique ID of the proposal."""

    executor: str = betterproto.string_field(2)
    """executor is the account address used to execute the proposal."""


@dataclass(eq=False, repr=False)
class MsgExecResponse(betterproto.Message):
    """MsgExecResponse is the Msg/Exec request type."""

    result: "ProposalExecutorResult" = betterproto.enum_field(2)
    """result is the final result of the proposal execution."""


@dataclass(eq=False, repr=False)
class MsgLeaveGroup(betterproto.Message):
    """MsgLeaveGroup is the Msg/LeaveGroup request type."""

    address: str = betterproto.string_field(1)
    """address is the account address of the group member."""

    group_id: int = betterproto.uint64_field(2)
    """group_id is the unique ID of the group."""


@dataclass(eq=False, repr=False)
class MsgLeaveGroupResponse(betterproto.Message):
    """MsgLeaveGroupResponse is the Msg/LeaveGroup response type."""

    pass


@dataclass(eq=False, repr=False)
class EventCreateGroup(betterproto.Message):
    """EventCreateGroup is an event emitted when a group is created."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""


@dataclass(eq=False, repr=False)
class EventUpdateGroup(betterproto.Message):
    """EventUpdateGroup is an event emitted when a group is updated."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""


@dataclass(eq=False, repr=False)
class EventCreateGroupPolicy(betterproto.Message):
    """
    EventCreateGroupPolicy is an event emitted when a group policy is created.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of the group policy."""


@dataclass(eq=False, repr=False)
class EventUpdateGroupPolicy(betterproto.Message):
    """
    EventUpdateGroupPolicy is an event emitted when a group policy is updated.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of the group policy."""


@dataclass(eq=False, repr=False)
class EventSubmitProposal(betterproto.Message):
    """EventSubmitProposal is an event emitted when a proposal is created."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of the proposal."""


@dataclass(eq=False, repr=False)
class EventWithdrawProposal(betterproto.Message):
    """
    EventWithdrawProposal is an event emitted when a proposal is withdrawn.
    """

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of the proposal."""


@dataclass(eq=False, repr=False)
class EventVote(betterproto.Message):
    """EventVote is an event emitted when a voter votes on a proposal."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of the proposal."""


@dataclass(eq=False, repr=False)
class EventExec(betterproto.Message):
    """EventExec is an event emitted when a proposal is executed."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of the proposal."""

    result: "ProposalExecutorResult" = betterproto.enum_field(2)
    """result is the proposal execution result."""

    logs: str = betterproto.string_field(3)
    """logs contains error logs in case the execution result is FAILURE."""


@dataclass(eq=False, repr=False)
class EventLeaveGroup(betterproto.Message):
    """
    EventLeaveGroup is an event emitted when group member leaves the group.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""

    address: str = betterproto.string_field(2)
    """address is the account address of the group member."""


@dataclass(eq=False, repr=False)
class EventProposalPruned(betterproto.Message):
    """EventProposalPruned is an event emitted when a proposal is pruned."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of the proposal."""

    status: "ProposalStatus" = betterproto.enum_field(2)
    """
    status is the proposal status (UNSPECIFIED, SUBMITTED, ACCEPTED, REJECTED, ABORTED, WITHDRAWN).
    """

    tally_result: "TallyResult" = betterproto.message_field(3)
    """tally_result is the proposal tally result (when applicable)."""


@dataclass(eq=False, repr=False)
class QueryGroupInfoRequest(betterproto.Message):
    """QueryGroupInfoRequest is the Query/GroupInfo request type."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""


@dataclass(eq=False, repr=False)
class QueryGroupInfoResponse(betterproto.Message):
    """QueryGroupInfoResponse is the Query/GroupInfo response type."""

    info: "GroupInfo" = betterproto.message_field(1)
    """info is the GroupInfo of the group."""


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoRequest(betterproto.Message):
    """
    QueryGroupPolicyInfoRequest is the Query/GroupPolicyInfo request type.
    """

    address: str = betterproto.string_field(1)
    """address is the account address of the group policy."""


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoResponse(betterproto.Message):
    """
    QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.
    """

    info: "GroupPolicyInfo" = betterproto.message_field(1)
    """info is the GroupPolicyInfo of the group policy."""


@dataclass(eq=False, repr=False)
class QueryGroupMembersRequest(betterproto.Message):
    """QueryGroupMembersRequest is the Query/GroupMembers request type."""

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupMembersResponse(betterproto.Message):
    """
    QueryGroupMembersResponse is the Query/GroupMembersResponse response type.
    """

    members: List["GroupMember"] = betterproto.message_field(1)
    """members are the members of the group with given group_id."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminRequest(betterproto.Message):
    """QueryGroupsByAdminRequest is the Query/GroupsByAdmin request type."""

    admin: str = betterproto.string_field(1)
    """admin is the account address of a group's admin."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminResponse(betterproto.Message):
    """
    QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type.
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """groups are the groups info with the provided admin."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupRequest(betterproto.Message):
    """
    QueryGroupPoliciesByGroupRequest is the Query/GroupPoliciesByGroup request type.
    """

    group_id: int = betterproto.uint64_field(1)
    """group_id is the unique ID of the group policy's group."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupResponse(betterproto.Message):
    """
    QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type.
    """

    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    """
    group_policies are the group policies info associated with the provided group.
    """

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminRequest(betterproto.Message):
    """
    QueryGroupPoliciesByAdminRequest is the Query/GroupPoliciesByAdmin request type.
    """

    admin: str = betterproto.string_field(1)
    """admin is the admin address of the group policy."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminResponse(betterproto.Message):
    """
    QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type.
    """

    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    """group_policies are the group policies info with provided admin."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryProposalRequest(betterproto.Message):
    """QueryProposalRequest is the Query/Proposal request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""


@dataclass(eq=False, repr=False)
class QueryProposalResponse(betterproto.Message):
    """QueryProposalResponse is the Query/Proposal response type."""

    proposal: "Proposal" = betterproto.message_field(1)
    """proposal is the proposal info."""


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyRequest(betterproto.Message):
    """
    QueryProposalsByGroupPolicyRequest is the Query/ProposalByGroupPolicy request type.
    """

    address: str = betterproto.string_field(1)
    """
    address is the account address of the group policy related to proposals.
    """

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyResponse(betterproto.Message):
    """
    QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type.
    """

    proposals: List["Proposal"] = betterproto.message_field(1)
    """proposals are the proposals with given group policy."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterRequest(betterproto.Message):
    """
    QueryVoteByProposalVoterRequest is the Query/VoteByProposalVoter request type.
    """

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""

    voter: str = betterproto.string_field(2)
    """voter is a proposal voter account address."""


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterResponse(betterproto.Message):
    """
    QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type.
    """

    vote: "Vote" = betterproto.message_field(1)
    """vote is the vote with given proposal_id and voter."""


@dataclass(eq=False, repr=False)
class QueryVotesByProposalRequest(betterproto.Message):
    """
    QueryVotesByProposalRequest is the Query/VotesByProposal request type.
    """

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique ID of a proposal."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryVotesByProposalResponse(betterproto.Message):
    """
    QueryVotesByProposalResponse is the Query/VotesByProposal response type.
    """

    votes: List["Vote"] = betterproto.message_field(1)
    """votes are the list of votes for given proposal_id."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryVotesByVoterRequest(betterproto.Message):
    """QueryVotesByVoterRequest is the Query/VotesByVoter request type."""

    voter: str = betterproto.string_field(1)
    """voter is a proposal voter account address."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryVotesByVoterResponse(betterproto.Message):
    """QueryVotesByVoterResponse is the Query/VotesByVoter response type."""

    votes: List["Vote"] = betterproto.message_field(1)
    """votes are the list of votes by given voter."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberRequest(betterproto.Message):
    """QueryGroupsByMemberRequest is the Query/GroupsByMember request type."""

    address: str = betterproto.string_field(1)
    """address is the group member address."""

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberResponse(betterproto.Message):
    """
    QueryGroupsByMemberResponse is the Query/GroupsByMember response type.
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """groups are the groups info with the provided group member."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryTallyResultRequest(betterproto.Message):
    """QueryTallyResultRequest is the Query/TallyResult request type."""

    proposal_id: int = betterproto.uint64_field(1)
    """proposal_id is the unique id of a proposal."""


@dataclass(eq=False, repr=False)
class QueryTallyResultResponse(betterproto.Message):
    """QueryTallyResultResponse is the Query/TallyResult response type."""

    tally: "TallyResult" = betterproto.message_field(1)
    """tally defines the requested tally."""


@dataclass(eq=False, repr=False)
class QueryGroupsRequest(betterproto.Message):
    """
    QueryGroupsRequest is the Query/Groups request type.

     Since: cosmos-sdk 0.47.1
    """

    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryGroupsResponse(betterproto.Message):
    """
    QueryGroupsResponse is the Query/Groups response type.

     Since: cosmos-sdk 0.47.1
    """

    groups: List["GroupInfo"] = betterproto.message_field(1)
    """`groups` is all the groups present in state."""

    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the group module's genesis state."""

    group_seq: int = betterproto.uint64_field(1)
    """
    group_seq is the group table orm.Sequence,
     it is used to get the next group ID.
    """

    groups: List["GroupInfo"] = betterproto.message_field(2)
    """groups is the list of groups info."""

    group_members: List["GroupMember"] = betterproto.message_field(3)
    """group_members is the list of groups members."""

    group_policy_seq: int = betterproto.uint64_field(4)
    """
    group_policy_seq is the group policy table orm.Sequence,
     it is used to generate the next group policy account address.
    """

    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(5)
    """group_policies is the list of group policies info."""

    proposal_seq: int = betterproto.uint64_field(6)
    """
    proposal_seq is the proposal table orm.Sequence,
     it is used to get the next proposal ID.
    """

    proposals: List["Proposal"] = betterproto.message_field(7)
    """proposals is the list of proposals."""

    votes: List["Vote"] = betterproto.message_field(8)
    """votes is the list of votes."""


class MsgStub(betterproto.ServiceStub):
    async def create_group(
        self,
        msg_create_group: "MsgCreateGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateGroupResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroup",
            msg_create_group,
            MsgCreateGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_members(
        self,
        msg_update_group_members: "MsgUpdateGroupMembers",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupMembersResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupMembers",
            msg_update_group_members,
            MsgUpdateGroupMembersResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_admin(
        self,
        msg_update_group_admin: "MsgUpdateGroupAdmin",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupAdmin",
            msg_update_group_admin,
            MsgUpdateGroupAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_metadata(
        self,
        msg_update_group_metadata: "MsgUpdateGroupMetadata",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupMetadataResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupMetadata",
            msg_update_group_metadata,
            MsgUpdateGroupMetadataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_group_policy(
        self,
        msg_create_group_policy: "MsgCreateGroupPolicy",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateGroupPolicyResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroupPolicy",
            msg_create_group_policy,
            MsgCreateGroupPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_group_with_policy(
        self,
        msg_create_group_with_policy: "MsgCreateGroupWithPolicy",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateGroupWithPolicyResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroupWithPolicy",
            msg_create_group_with_policy,
            MsgCreateGroupWithPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_policy_admin(
        self,
        msg_update_group_policy_admin: "MsgUpdateGroupPolicyAdmin",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupPolicyAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyAdmin",
            msg_update_group_policy_admin,
            MsgUpdateGroupPolicyAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_policy_decision_policy(
        self,
        msg_update_group_policy_decision_policy: "MsgUpdateGroupPolicyDecisionPolicy",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupPolicyDecisionPolicyResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyDecisionPolicy",
            msg_update_group_policy_decision_policy,
            MsgUpdateGroupPolicyDecisionPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_policy_metadata(
        self,
        msg_update_group_policy_metadata: "MsgUpdateGroupPolicyMetadata",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupPolicyMetadataResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyMetadata",
            msg_update_group_policy_metadata,
            MsgUpdateGroupPolicyMetadataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def submit_proposal(
        self,
        msg_submit_proposal: "MsgSubmitProposal",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgSubmitProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/SubmitProposal",
            msg_submit_proposal,
            MsgSubmitProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def withdraw_proposal(
        self,
        msg_withdraw_proposal: "MsgWithdrawProposal",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgWithdrawProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/WithdrawProposal",
            msg_withdraw_proposal,
            MsgWithdrawProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def vote(
        self,
        msg_vote: "MsgVote",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgVoteResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/Vote",
            msg_vote,
            MsgVoteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def exec(
        self,
        msg_exec: "MsgExec",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgExecResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/Exec",
            msg_exec,
            MsgExecResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def leave_group(
        self,
        msg_leave_group: "MsgLeaveGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgLeaveGroupResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Msg/LeaveGroup",
            msg_leave_group,
            MsgLeaveGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def group_info(
        self,
        query_group_info_request: "QueryGroupInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupInfoResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupInfo",
            query_group_info_request,
            QueryGroupInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policy_info(
        self,
        query_group_policy_info_request: "QueryGroupPolicyInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPolicyInfoResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPolicyInfo",
            query_group_policy_info_request,
            QueryGroupPolicyInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_members(
        self,
        query_group_members_request: "QueryGroupMembersRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupMembersResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupMembers",
            query_group_members_request,
            QueryGroupMembersResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups_by_admin(
        self,
        query_groups_by_admin_request: "QueryGroupsByAdminRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsByAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByAdmin",
            query_groups_by_admin_request,
            QueryGroupsByAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policies_by_group(
        self,
        query_group_policies_by_group_request: "QueryGroupPoliciesByGroupRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPoliciesByGroupResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByGroup",
            query_group_policies_by_group_request,
            QueryGroupPoliciesByGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def group_policies_by_admin(
        self,
        query_group_policies_by_admin_request: "QueryGroupPoliciesByAdminRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupPoliciesByAdminResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin",
            query_group_policies_by_admin_request,
            QueryGroupPoliciesByAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def proposal(
        self,
        query_proposal_request: "QueryProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/Proposal",
            query_proposal_request,
            QueryProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def proposals_by_group_policy(
        self,
        query_proposals_by_group_policy_request: "QueryProposalsByGroupPolicyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryProposalsByGroupPolicyResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy",
            query_proposals_by_group_policy_request,
            QueryProposalsByGroupPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def vote_by_proposal_voter(
        self,
        query_vote_by_proposal_voter_request: "QueryVoteByProposalVoterRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVoteByProposalVoterResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VoteByProposalVoter",
            query_vote_by_proposal_voter_request,
            QueryVoteByProposalVoterResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def votes_by_proposal(
        self,
        query_votes_by_proposal_request: "QueryVotesByProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVotesByProposalResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByProposal",
            query_votes_by_proposal_request,
            QueryVotesByProposalResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def votes_by_voter(
        self,
        query_votes_by_voter_request: "QueryVotesByVoterRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVotesByVoterResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByVoter",
            query_votes_by_voter_request,
            QueryVotesByVoterResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups_by_member(
        self,
        query_groups_by_member_request: "QueryGroupsByMemberRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsByMemberResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByMember",
            query_groups_by_member_request,
            QueryGroupsByMemberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def tally_result(
        self,
        query_tally_result_request: "QueryTallyResultRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTallyResultResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/TallyResult",
            query_tally_result_request,
            QueryTallyResultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def groups(
        self,
        query_groups_request: "QueryGroupsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsResponse":
        return await self._unary_unary(
            "/cosmos.group.v1.Query/Groups",
            query_groups_request,
            QueryGroupsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def create_group(self, msg_create_group: "MsgCreateGroup") -> "MsgCreateGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_members(
        self, msg_update_group_members: "MsgUpdateGroupMembers"
    ) -> "MsgUpdateGroupMembersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_admin(self, msg_update_group_admin: "MsgUpdateGroupAdmin") -> "MsgUpdateGroupAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_metadata(
        self, msg_update_group_metadata: "MsgUpdateGroupMetadata"
    ) -> "MsgUpdateGroupMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_group_policy(
        self, msg_create_group_policy: "MsgCreateGroupPolicy"
    ) -> "MsgCreateGroupPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_group_with_policy(
        self, msg_create_group_with_policy: "MsgCreateGroupWithPolicy"
    ) -> "MsgCreateGroupWithPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_admin(
        self, msg_update_group_policy_admin: "MsgUpdateGroupPolicyAdmin"
    ) -> "MsgUpdateGroupPolicyAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_decision_policy(
        self,
        msg_update_group_policy_decision_policy: "MsgUpdateGroupPolicyDecisionPolicy",
    ) -> "MsgUpdateGroupPolicyDecisionPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_metadata(
        self, msg_update_group_policy_metadata: "MsgUpdateGroupPolicyMetadata"
    ) -> "MsgUpdateGroupPolicyMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def submit_proposal(self, msg_submit_proposal: "MsgSubmitProposal") -> "MsgSubmitProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_proposal(self, msg_withdraw_proposal: "MsgWithdrawProposal") -> "MsgWithdrawProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote(self, msg_vote: "MsgVote") -> "MsgVoteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exec(self, msg_exec: "MsgExec") -> "MsgExecResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def leave_group(self, msg_leave_group: "MsgLeaveGroup") -> "MsgLeaveGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_group(self, stream: "grpclib.server.Stream[MsgCreateGroup, MsgCreateGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.create_group(request)
        await stream.send_message(response)

    async def __rpc_update_group_members(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupMembers, MsgUpdateGroupMembersResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_members(request)
        await stream.send_message(response)

    async def __rpc_update_group_admin(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupAdmin, MsgUpdateGroupAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_admin(request)
        await stream.send_message(response)

    async def __rpc_update_group_metadata(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupMetadata, MsgUpdateGroupMetadataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_metadata(request)
        await stream.send_message(response)

    async def __rpc_create_group_policy(
        self,
        stream: "grpclib.server.Stream[MsgCreateGroupPolicy, MsgCreateGroupPolicyResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_group_policy(request)
        await stream.send_message(response)

    async def __rpc_create_group_with_policy(
        self,
        stream: "grpclib.server.Stream[MsgCreateGroupWithPolicy, MsgCreateGroupWithPolicyResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_group_with_policy(request)
        await stream.send_message(response)

    async def __rpc_update_group_policy_admin(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupPolicyAdmin, MsgUpdateGroupPolicyAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_policy_admin(request)
        await stream.send_message(response)

    async def __rpc_update_group_policy_decision_policy(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupPolicyDecisionPolicy, MsgUpdateGroupPolicyDecisionPolicyResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_policy_decision_policy(request)
        await stream.send_message(response)

    async def __rpc_update_group_policy_metadata(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupPolicyMetadata, MsgUpdateGroupPolicyMetadataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_policy_metadata(request)
        await stream.send_message(response)

    async def __rpc_submit_proposal(
        self,
        stream: "grpclib.server.Stream[MsgSubmitProposal, MsgSubmitProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.submit_proposal(request)
        await stream.send_message(response)

    async def __rpc_withdraw_proposal(
        self,
        stream: "grpclib.server.Stream[MsgWithdrawProposal, MsgWithdrawProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.withdraw_proposal(request)
        await stream.send_message(response)

    async def __rpc_vote(self, stream: "grpclib.server.Stream[MsgVote, MsgVoteResponse]") -> None:
        request = await stream.recv_message()
        response = await self.vote(request)
        await stream.send_message(response)

    async def __rpc_exec(self, stream: "grpclib.server.Stream[MsgExec, MsgExecResponse]") -> None:
        request = await stream.recv_message()
        response = await self.exec(request)
        await stream.send_message(response)

    async def __rpc_leave_group(self, stream: "grpclib.server.Stream[MsgLeaveGroup, MsgLeaveGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.leave_group(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.group.v1.Msg/CreateGroup": grpclib.const.Handler(
                self.__rpc_create_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroup,
                MsgCreateGroupResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupMembers": grpclib.const.Handler(
                self.__rpc_update_group_members,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupMembers,
                MsgUpdateGroupMembersResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupAdmin": grpclib.const.Handler(
                self.__rpc_update_group_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupAdmin,
                MsgUpdateGroupAdminResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupMetadata": grpclib.const.Handler(
                self.__rpc_update_group_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupMetadata,
                MsgUpdateGroupMetadataResponse,
            ),
            "/cosmos.group.v1.Msg/CreateGroupPolicy": grpclib.const.Handler(
                self.__rpc_create_group_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroupPolicy,
                MsgCreateGroupPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/CreateGroupWithPolicy": grpclib.const.Handler(
                self.__rpc_create_group_with_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroupWithPolicy,
                MsgCreateGroupWithPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyAdmin": grpclib.const.Handler(
                self.__rpc_update_group_policy_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyAdmin,
                MsgUpdateGroupPolicyAdminResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyDecisionPolicy": grpclib.const.Handler(
                self.__rpc_update_group_policy_decision_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyDecisionPolicy,
                MsgUpdateGroupPolicyDecisionPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyMetadata": grpclib.const.Handler(
                self.__rpc_update_group_policy_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyMetadata,
                MsgUpdateGroupPolicyMetadataResponse,
            ),
            "/cosmos.group.v1.Msg/SubmitProposal": grpclib.const.Handler(
                self.__rpc_submit_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSubmitProposal,
                MsgSubmitProposalResponse,
            ),
            "/cosmos.group.v1.Msg/WithdrawProposal": grpclib.const.Handler(
                self.__rpc_withdraw_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawProposal,
                MsgWithdrawProposalResponse,
            ),
            "/cosmos.group.v1.Msg/Vote": grpclib.const.Handler(
                self.__rpc_vote,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgVote,
                MsgVoteResponse,
            ),
            "/cosmos.group.v1.Msg/Exec": grpclib.const.Handler(
                self.__rpc_exec,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExec,
                MsgExecResponse,
            ),
            "/cosmos.group.v1.Msg/LeaveGroup": grpclib.const.Handler(
                self.__rpc_leave_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgLeaveGroup,
                MsgLeaveGroupResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def group_info(self, query_group_info_request: "QueryGroupInfoRequest") -> "QueryGroupInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policy_info(
        self, query_group_policy_info_request: "QueryGroupPolicyInfoRequest"
    ) -> "QueryGroupPolicyInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_members(
        self, query_group_members_request: "QueryGroupMembersRequest"
    ) -> "QueryGroupMembersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_admin(
        self, query_groups_by_admin_request: "QueryGroupsByAdminRequest"
    ) -> "QueryGroupsByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_group(
        self, query_group_policies_by_group_request: "QueryGroupPoliciesByGroupRequest"
    ) -> "QueryGroupPoliciesByGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_admin(
        self, query_group_policies_by_admin_request: "QueryGroupPoliciesByAdminRequest"
    ) -> "QueryGroupPoliciesByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposal(self, query_proposal_request: "QueryProposalRequest") -> "QueryProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposals_by_group_policy(
        self,
        query_proposals_by_group_policy_request: "QueryProposalsByGroupPolicyRequest",
    ) -> "QueryProposalsByGroupPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote_by_proposal_voter(
        self, query_vote_by_proposal_voter_request: "QueryVoteByProposalVoterRequest"
    ) -> "QueryVoteByProposalVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_proposal(
        self, query_votes_by_proposal_request: "QueryVotesByProposalRequest"
    ) -> "QueryVotesByProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_voter(
        self, query_votes_by_voter_request: "QueryVotesByVoterRequest"
    ) -> "QueryVotesByVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_member(
        self, query_groups_by_member_request: "QueryGroupsByMemberRequest"
    ) -> "QueryGroupsByMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tally_result(self, query_tally_result_request: "QueryTallyResultRequest") -> "QueryTallyResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups(self, query_groups_request: "QueryGroupsRequest") -> "QueryGroupsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_group_info(
        self,
        stream: "grpclib.server.Stream[QueryGroupInfoRequest, QueryGroupInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_info(request)
        await stream.send_message(response)

    async def __rpc_group_policy_info(
        self,
        stream: "grpclib.server.Stream[QueryGroupPolicyInfoRequest, QueryGroupPolicyInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policy_info(request)
        await stream.send_message(response)

    async def __rpc_group_members(
        self,
        stream: "grpclib.server.Stream[QueryGroupMembersRequest, QueryGroupMembersResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_members(request)
        await stream.send_message(response)

    async def __rpc_groups_by_admin(
        self,
        stream: "grpclib.server.Stream[QueryGroupsByAdminRequest, QueryGroupsByAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.groups_by_admin(request)
        await stream.send_message(response)

    async def __rpc_group_policies_by_group(
        self,
        stream: "grpclib.server.Stream[QueryGroupPoliciesByGroupRequest, QueryGroupPoliciesByGroupResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policies_by_group(request)
        await stream.send_message(response)

    async def __rpc_group_policies_by_admin(
        self,
        stream: "grpclib.server.Stream[QueryGroupPoliciesByAdminRequest, QueryGroupPoliciesByAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.group_policies_by_admin(request)
        await stream.send_message(response)

    async def __rpc_proposal(
        self,
        stream: "grpclib.server.Stream[QueryProposalRequest, QueryProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.proposal(request)
        await stream.send_message(response)

    async def __rpc_proposals_by_group_policy(
        self,
        stream: "grpclib.server.Stream[QueryProposalsByGroupPolicyRequest, QueryProposalsByGroupPolicyResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.proposals_by_group_policy(request)
        await stream.send_message(response)

    async def __rpc_vote_by_proposal_voter(
        self,
        stream: "grpclib.server.Stream[QueryVoteByProposalVoterRequest, QueryVoteByProposalVoterResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.vote_by_proposal_voter(request)
        await stream.send_message(response)

    async def __rpc_votes_by_proposal(
        self,
        stream: "grpclib.server.Stream[QueryVotesByProposalRequest, QueryVotesByProposalResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.votes_by_proposal(request)
        await stream.send_message(response)

    async def __rpc_votes_by_voter(
        self,
        stream: "grpclib.server.Stream[QueryVotesByVoterRequest, QueryVotesByVoterResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.votes_by_voter(request)
        await stream.send_message(response)

    async def __rpc_groups_by_member(
        self,
        stream: "grpclib.server.Stream[QueryGroupsByMemberRequest, QueryGroupsByMemberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.groups_by_member(request)
        await stream.send_message(response)

    async def __rpc_tally_result(
        self,
        stream: "grpclib.server.Stream[QueryTallyResultRequest, QueryTallyResultResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.tally_result(request)
        await stream.send_message(response)

    async def __rpc_groups(self, stream: "grpclib.server.Stream[QueryGroupsRequest, QueryGroupsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.groups(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.group.v1.Query/GroupInfo": grpclib.const.Handler(
                self.__rpc_group_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupInfoRequest,
                QueryGroupInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupPolicyInfo": grpclib.const.Handler(
                self.__rpc_group_policy_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPolicyInfoRequest,
                QueryGroupPolicyInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupMembers": grpclib.const.Handler(
                self.__rpc_group_members,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupMembersRequest,
                QueryGroupMembersResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByAdmin": grpclib.const.Handler(
                self.__rpc_groups_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByAdminRequest,
                QueryGroupsByAdminResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByGroup": grpclib.const.Handler(
                self.__rpc_group_policies_by_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByGroupRequest,
                QueryGroupPoliciesByGroupResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin": grpclib.const.Handler(
                self.__rpc_group_policies_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByAdminRequest,
                QueryGroupPoliciesByAdminResponse,
            ),
            "/cosmos.group.v1.Query/Proposal": grpclib.const.Handler(
                self.__rpc_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalRequest,
                QueryProposalResponse,
            ),
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy": grpclib.const.Handler(
                self.__rpc_proposals_by_group_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalsByGroupPolicyRequest,
                QueryProposalsByGroupPolicyResponse,
            ),
            "/cosmos.group.v1.Query/VoteByProposalVoter": grpclib.const.Handler(
                self.__rpc_vote_by_proposal_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVoteByProposalVoterRequest,
                QueryVoteByProposalVoterResponse,
            ),
            "/cosmos.group.v1.Query/VotesByProposal": grpclib.const.Handler(
                self.__rpc_votes_by_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByProposalRequest,
                QueryVotesByProposalResponse,
            ),
            "/cosmos.group.v1.Query/VotesByVoter": grpclib.const.Handler(
                self.__rpc_votes_by_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByVoterRequest,
                QueryVotesByVoterResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByMember": grpclib.const.Handler(
                self.__rpc_groups_by_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByMemberRequest,
                QueryGroupsByMemberResponse,
            ),
            "/cosmos.group.v1.Query/TallyResult": grpclib.const.Handler(
                self.__rpc_tally_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTallyResultRequest,
                QueryTallyResultResponse,
            ),
            "/cosmos.group.v1.Query/Groups": grpclib.const.Handler(
                self.__rpc_groups,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsRequest,
                QueryGroupsResponse,
            ),
        }
